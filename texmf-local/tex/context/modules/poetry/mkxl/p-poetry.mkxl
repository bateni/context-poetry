%D \module
%D   [      file=p-poetry,
%D        version=0.1,
%D          title=\CONTEXT\ User Module,
%D       subtitle=typeset Persian poetry,
%D         author={Mohammad Hossein Bateni},
%D           date=\currentdate,
%D      copyright={Mohammad Hossein Bateni},
%D        license=MIT License]

% Poetry: Typesetting Persian poetry in ConTeXt
% Copyright (C) 2025  Mohammad Hossein Bateni

\writestatus{loading}{Loading poetry module}

\unprotect

\installnamespace{poetry}
\installcommandhandler \????poetry {poetry} \????poetry

\definedataset[PoetryLines]

\newcount\poetry_count
\poetry_count\zerocount

\newbox\poetry_line_box%
\newdimen\computed_box_width%
\newdimen\natural_box_width%

% todo: add system variables for new keys, values if needed.

\setuppoetry
  [\c!width=\v!fit, % local [availablehsize], broad? [full text width], fit, DIM
   \c!distance=4\emwidth,  
   \c!location=\v!left, % middle, right 
   %%%%\c!separator=\vl\hskip.25em\vl,
   \c!strut=,  %% not implemented
   \c!after=\blank[line], % comes after \par
   kashida=off,
   %%%randomseed=123,
   %style=
   %color=
  ]

\appendtoks
    \setuxvalue{\e!start\currentpoetry}{\startpoetry[\currentpoetry]}%
    \setuxvalue{\e!stop \currentpoetry}{\stoppoetry}%
\to \everydefinepoetry

\tolerant\protected\def\startpoetry[#1]#*[#2]%
  {%
   \begingroup
   \ifarguments
     \def\currentpoetry{}%
   \or
     \doifelseassignment{#1}
       {\edef\currentpoetry{}%
        \setupcurrentpoetry[#1]}
       {\def\currentpoetry{#1}}%
   \else
     \edef\currentpoetry{#1}%
     \setupcurrentpoetry[#2]%
   \fi%
   \usepoetrystyleandcolor\c!style\c!color
   \poetryparameter\c!before%
   \par%
   %% todo: change to sth other than scratchwidth
   %% Figure out environment's width
   \doifelse{\poetryparameter\c!width}{\v!local}
               {\scratchwidth\availablehsize}
             {\doifelse{\poetryparameter\c!width}{\v!fit}
               {\lookup_max_width%
                \scratchwidth\current_max_width}
               {\scratchwidth\poetryparameter\c!width\relax}}%
   %% Figure out location (left, middle, right)
   \edef\poetry_line_location_left_skip{%
%     \poetry_skip_for_alignment{\the\availablehsize}{\current_max_width}{\poetryparameter\c!location}}%
     \poetry_skip_for_alignment{\the\availablehsize}{\the\scratchwidth}{\poetryparameter\c!location}}%
  }

\permanent\protected\def\stoppoetry
  {%
   \poetry_save_computed_widths%
   %\par%
   \blank[back]%
   \poetryparameter\c!after%
   %\par
   \endgroup%
  }

% #1: total width (dimen),  #2: current item's width (dimen),  #3: left, middle, right
\def\poetry_skip_for_alignment#1#2#3{\ctxlua{poetryAlignmentSkip("#1","#2","#3")}}%

\startluacode
  local log        = logs.reporter("poetry","width")
  
  function poetryAlignmentSkip(total_width, current_width, alignment_option)
    log('%a - %a - %a', total_width, current_width, alignment_option)
    total_width   = string.todimen(total_width)
    current_width = string.todimen(current_width)
    if total_width <= current_width then return end
    
    local multiplier = 1
    -- todo: use interface variables
    if alignment_option == "left"  then multiplier = 0 end
    if alignment_option == "right" then multiplier = 2 end
    local skip_amount = (total_width - current_width) / 2 * multiplier

    context.hskip(skip_amount / 2^16 .. 'pt')
  end
\stopluacode

%D Next we define the command for adding one line of poetry, which may
%D consist of one or two pieces.

\installnamespace{poetryline}
\installcommandhandler \????poetryline {poetryline} \????poetryline

\setuppoetryline
  [\c!coupling=\v!default, % or NUM, or NUM:NUM?
   %\c!coupling\c!left=,
   %\c!coupling\c!right=,
   \c!alternative=\v!auto, % stacked, line, step or staggered?, middle, left, right
   \c!n=2, % = couplet, or 1 = hemistich
   \c!separator=,  % {\hss - \hss}
   \c!distance=,
   %\c!distance=1cm, % between two hemistichs
   \c!before=\blank[standard], % or nothing?
   \c!after=\blank[standard], % or nothing?
   %style=
   %color=
  ]

\appendtoks
  \setuxvalue{\currentpoetryline}{\poetryline[\currentpoetryline]}
\to \everydefinepoetryline
  
\tolerant\protected\def\poetryline[#1]#*[#2]%
  {%
   \begingroup%
   \ifarguments
     \def\currentpoetryline{}%
   \or
     \doifelseassignment{#1}
       {\edef\currentpoetryline{}%
        \setupcurrentpoetryline[#1]}
       {\def\currentpoetryline{#1}}%
   \else
     \edef\currentpoetryline{#1}%
     \setupcurrentpoetryline[#2]%
   \fi%
   %% Figure distance and separator settings
   \edef\poetry_intra_line_distance{\poetrylineparameter\c!distance}%
   \ifempty\poetry_intra_line_distance%
   \edef\poetry_intra_line_distance{\poetryparameter\c!distance}%
   \fi%
   \ifempty\poetry_intra_line_distance\else%
   \edef\poetry_intra_line_distance{\poetryparameter\c!distance}%
   \fi%
   %%
   \edef\poetry_intra_line_separator{\poetrylineparameter\c!separator}%
   \ifempty\poetry_intra_line_separator%
   \edef\poetry_intra_line_separator{\poetryparameter\c!separator}%
   \fi%
   %% Figure out coupling of (half) lines
   \edef\poetry_line_coupling{\poetrylineparameter{\c!coupling}}%
   \edef\poetry_line_coupling_left{\poetrylineparameter{\c!coupling\c!left}}%
   \ifempty\poetry_line_coupling_left\edef\poetry_line_coupling_left{\poetry_line_coupling}\fi%
   \edef\poetry_line_coupling_right{\poetrylineparameter{\c!coupling\c!right}}%
   \ifempty\poetry_line_coupling_right\edef\poetry_line_coupling_right{\poetry_line_coupling}\fi%
   %
   %coupling:\poetry_line_coupling:\poetry_line_coupling_left:\poetry_line_coupling_right;
   \par%
   \usepoetrylinestyleandcolor\c!style\c!color%
   \poetrylineparameter\c!before%
   %%
   \doifelse{\poetrylineparameter\c!n}{2}
            {\couplet}
            {\singlet}%
  }

\protected\def\check_poetry_line#1#2%
  {% #1: group, #2: content
    \setbox\poetry_line_box\hbox{#2}%
    \natural_box_width=\wd\poetry_line_box%
    \lookup_and_update_group_width{#1}{\the\natural_box_width}%
    \ctxlua{stretchText("\poetryparameter{kashida}", "\group_width")}%
    %% todo: why are the following two lines needed?
    \computed_box_width=\group_width\relax%
    %\ifdim\natural_box_width<\computed_box_width\relax%
       \setbox\poetry_line_box\hbox to \computed_box_width{\unhbox\poetry_line_box}%
    %\fi%
  } %% end of check_poetry_line  

\protected\def\singlet#1%
  {%
    \dontleavehmode%
    \check_poetry_line{\poetry_line_coupling_left}{#1}%
    \update_max_width\group_width%
    % only left and right matter. everything else is treated as middle
    \edef\actual_alternative{\poetrylineparameter\c!alternative}%   
    %\hbox to \scratchwidth{%
    \hbox {%
      \poetry_line_location_left_skip%
      \lookup_max_width%
      \edef\poetry_line_location_left_skip{%
        \poetry_skip_for_alignment{\the\scratchwidth}{\the\wd\poetry_line_box}{\poetrylineparameter\c!alternative}}%
      \poetry_line_location_left_skip%
        \box\poetry_line_box%
    }%
    \par%
    \poetrylineparameter\c!after%
    \endgroup
  } %% end of singlet

\protected\def\couplet#1#2%
  {%
    \dontleavehmode%
    \lookup_max_width%
    \poetry_line_location_left_skip%
    \hbox to \scratchwidth{%
      \lookup_max_width%
%      \edef\poetry_line_location_left_skip{%
%        \poetry_skip_for_alignment{\the\scratchwidth}{\the\wd\poetry_line_box}{\poetrylineparameter\c!alternative}}%
%      \poetry_line_location_left_skip%
      \hbox to \scratchwidth{%
      \check_poetry_line{\poetry_line_coupling_left}{#1}%
      \edef\group_width_left{\group_width}%
      \box\poetry_line_box%
      %
      \doiftextelse{\poetry_intra_line_separator}
                   {\hbox to \poetry_intra_line_distance{\poetry_intra_line_separator}}
                   {\hskip\poetry_intra_line_distance}
      %    
      \check_poetry_line{\poetry_line_coupling_right}{#2}%
      \box\poetry_line_box%
      \update_max_width{\the\dimexpr\group_width_left+\group_width+\poetry_intra_line_distance\relax}%
      }%
      \poetry_line_location_left_skip%
    }%
    \poetrylineparameter\c!after%
    \endgroup
  }
  
\def\lookup_and_update_group_width#1#2%
  {% #1: group id,  #2: natural width
    \ctxlua{poetryLookupAndUpdateGroupWidth("\the\poetry_count","#1","#2",
        "\datasetvariable{PoetryLines}{x\the\poetry_count}{y#1}")}%
  }

\def\update_max_width#1%
  {% #1: width of current line
    \ctxlua{poetryUpdateMaxWidth("\the\poetry_count","#1")}%
  }

\def\lookup_max_width%
  {%
    \edef\current_max_width{\datasetvariable{PoetryLines}{x\the\poetry_count}{max}pt}%
    \doif{\current_max_width}{nil}{\edef\current_max_width{}}%
    \ifempty\current_max_width\edef\current_max_width{1cm}\fi%
    %\current_max_width%
  }
  
\def\poetry_save_computed_widths%
  {%
    \ctxlua{poetrySaveComputedWidths(\the\poetry_count)}%
    \global\advance\poetry_count\plusone\relax%
  }
  
\startluacode
  thirddata           = thirddata           or {}
  thirddata.poetry    = thirddata.poetry    or {}
  
  local poetry        = thirddata.poetry
  poetry.widths       = {}

  function poetryLookupAndUpdateGroupWidth(instance_id, group_id, natural_width, saved_width)
    instance_id = 'x' .. instance_id
    group_id    = 'y' .. group_id

    -- todo: I think the following is not fully flushed until the end of this function, so we can't
    -- pull back the result. Once this works, we can reuse group_width as placeholder for it.
    -- context("\\edef\\poetry_dummy_variable{HI}")  --{\\datasetvariable{PoetryLines}{x0}{ydefault}}")
    -- print('val:', tokens.getters.macro("poetry_dummy_variable"))
    -- the other workaround is to rely on implementation of datasetvariable and look up the table ourselves.
    -- see the code in core-dat.lua line 178.
    
    -- todo: how can we "call" TeX code and get back the results instead of it being written to the TeX stream?
    --    local looked_up_width = context.datasetvariable("PoetryLines", instance_id, group_id) or 0
    local looked_up_width = tonumber(saved_width) or 0

    local instance = poetry.widths[instance_id] or {}
    poetry.widths[instance_id] = instance
    local width = instance[group_id] or 0

    natural_width = tonumber(natural_width:match('[.%d]+'))
    if natural_width > width then
      width = natural_width
    end
    instance[group_id] = width
    
    tokens.setters.macro("group_width", looked_up_width .. 'pt')
  end

  function poetrySaveComputedWidths(instance_id)
    instance_id = 'x' .. instance_id
    local instance = poetry.widths[instance_id] or {}
    local vals = {}
    for k, v in pairs(instance) do
      vals[k] = v
    end
    context.setdataset({"PoetryLines"}, {instance_id}, vals)
  end

  function poetryUpdateMaxWidth(instance_id, current_width)
    instance_id = 'x' .. instance_id
    current_width = tonumber(current_width:match('[.%d]+')) or 0  -- assumes 'pt' suffix
    
    local instance = poetry.widths[instance_id] or {}
    poetry.widths[instance_id] = instance
    local width = instance.max or 0

    if current_width > width then
      width = current_width
    end
    instance.max = width
  end
\stopluacode

\startluacode
  local nuts       = nodes.nuts
  local getid      = nuts.getid
  local fields     = node.fields
  local getlist    = nuts.getlist
  local setlist    = nuts.setlist
  local getnext    = nuts.getnext
  local getprev    = nuts.getprev
  local getfield   = nuts.getfield
  local setfield   = nuts.setfield
  local getwidth   = nuts.getwidth
  local getboxglue = nuts.getboxglue
  local traverseid = nuts.traverseid
  local new_glyph  = nuts.pool.glyph
  local glyph_code = nodes.nodecodes.glyph
  local log        = logs.reporter("poetry","kashida")
  local chardata   = characters.data
  local getrandom  = utilities.randomizer.get

  math.setrandomseedi(0)
  
  function stretchText(enabled, desired_width)
    enabled = enabled == "on" or enabled == "true"
    -- this function uses nodes not nuts
    local head = tex.box.poetry_line_box
    local head = node.todirect(head)
    local list = getlist(head)
    
    local natural_width = getwidth(head)
    desired_width = string.todimen(desired_width)
    log('head %a -- width: %a %a', head, natural_width, desired_width)
    if desired_width <= natural_width then return end  -- nothing to be done

    if not enabled then
      list = nuts.hpack(list,desired_width,'exactly',listdir)
      setlist(head, list)
      list = getlist(list)
      return
    end
    
    -- let's keep track of all eligible positions
    local elipos = {}
    for n in traverseid(glyph_code, list) do
      local prv = getprev(n)
      if prv and getid(prv) == glyph_code then
        local char1, char2 = getfield(prv,'char'), getfield(n,'char')
        local data = chardata[char1]
        local char_kind = data and data.specials and data.specials[1]
        if char_kind == 'initial' or char_kind == 'medial' then
          elipos[#elipos+1] = n
        end
      end
    end
    log('count: %a', #elipos)
    if #elipos == 0 then return end  -- nothing can be done
    while true do
      local loc = getrandom("kashida", 1, #elipos)  --1
      local n = elipos[loc]
      local filler = nuts.copy(n)
      setfield(filler,'char',0x640)
      ls, nn = nuts.insertbefore(list,n,filler)
      local listdir = nil
      list = nuts.hpack(ls,desired_width,'exactly',listdir)
      -- todo: do I need to set head = list here? or setlist(head,list) or not?
      local set__, order__, sign = getboxglue(list)
      -- sign: 0 (great), sign: 1 (need more), sign: 2 (went too much)
      log('rehpack %a, glue sign %a', list, sign)
      list = getlist(list)
      setlist(head, list)
      if sign == 0 then break end
      if sign == 2 then
        -- undo last insert
        list = nuts.remove(list,filler)
        list = nuts.hpack(list,desired_width,'exactly',listdir)
        setlist(head, list)
        break
      end
    end
  end
\stopluacode

\protect
